You are acting as a senior React + TypeScript engineer with strong debugging instincts. The Markets page still shows â€œ$[object Object]â€ for the iShares Aerospace & Defense ETF (ticker ITA) even after adding a helper and tightening the types. Assume the backend is confirmed to return the correct JSON.

1 Â· Reproduce & inspect the raw payload
ts
Copy
Edit
// ğŸ” TEMP DEBUG â€” remove after fix
useEffect(() => {
  console.log('âš¡ raw defenseIndex payload â†’', JSON.stringify(defenseIndex, null, 2));
}, [defenseIndex]);
Verify whether defenseIndex sometimes arrives as

ts
Copy
Edit
{ price: number; change: number }    // âœ… current spec
or as

ts
Copy
Edit
{ ITA: { price: number; change: number } } // âŒ legacy wrapper
or even as a plain number/string. Copyâ€“paste the console output into the chat if needed.

2 Â· Strengthen the type system
Create an explicit type-guard so the compiler (and runtime) never confuses the shapes:

ts
Copy
Edit
type ITAPrice =
  | number
  | string
  | { price: number; change: number }
  | { ITA: { price: number; change: number } }; // legacy

function normaliseITA(value: ITAPrice): { price: number; change: number } | null {
  if (typeof value === 'number') return { price: value, change: 0 };
  if (typeof value === 'string' && !isNaN(Number(value)))
    return { price: Number(value), change: 0 };

  if (
    typeof value === 'object' &&
    value !== null &&
    'price' in value &&
    'change' in value
  )
    return { price: value.price as number, change: value.change as number };

  if (
    typeof value === 'object' &&
    value !== null &&
    'ITA' in value &&
    typeof (value as any).ITA === 'object'
  )
    return {
      price: (value as any).ITA.price as number,
      change: (value as any).ITA.change as number,
    };

  return null; // unrecognised shape
}
3 Â· Wire the normaliser into the component
tsx
Copy
Edit
const ita = normaliseITA(defenseIndex);

return (
  <MarketCard
    label="iShares Aerospace & Defense ETF (ITA)"
    price={ita?.price ?? NaN}
    change={ita?.change ?? NaN}
  />
);
4 Â· Update card rendering logic
Inside MarketCard (or equivalent), render nothing if the props are NaN, or show a spinner.

tsx
Copy
Edit
if (Number.isNaN(price) || Number.isNaN(change)) {
  return <Skeleton className="h-8 w-24" />;
}
5 Â· Add unit and runtime safety nets
Jest: feed the component every union-member shape and assert correct rendering (never â€œ[object Object]â€).

Runtime: if normaliseITA returns null, log an error with console.error('âš ï¸ Unrecognised ITA payload', defenseIndex).

6 Â· Acceptance criteria
The ITA card always shows e.g. â€œ$183.12 (+0.64 %)â€ or a skeleton while loading â€” never â€œ[object Object]â€.

No TypeScript any or unknown escapes the helper.

Tests pass and console logs are clean.

Return only the modified client/src/pages/markets.tsx, the new helper (e.g., src/utils/normaliseITA.ts), and updated tests. Include concise inline comments that explain each critical change.